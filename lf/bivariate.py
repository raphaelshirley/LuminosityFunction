#%matplotlib inline
#%config InlineBackend.figure_format = 'svg'

import matplotlib.pyplot as plt
plt.rc('figure', figsize=(10, 6))

import os
import time
import glob

from astropy import units as u
from astropy.coordinates import SkyCoord
from astropy.table import Column, Table, join
from astropy.cosmology import FlatLambdaCDM
from astropy.cosmology import Planck15
from astropy.cosmology import z_at_value
from astropy.constants import iau2015 as const
Lsun= const.L_sun.value

import numpy as np
from pymoc import MOC
import healpy as hp
#import pandas as pd #Astropy has group_by function so apandas isn't required.
import seaborn as sns

import warnings
#We ignore warnings - this is a little dangerous but a huge number of warnings are generated by empty cells later
warnings.filterwarnings('ignore')

from herschelhelp_internal.utils import inMoc, coords_to_hpidx, flux_to_mag, mag_to_flux
from herschelhelp_internal.masterlist import find_last_ml_suffix, nb_ccplots

from astropy.io.votable import parse_single_table

from pcigale.sed import SED
from pcigale.sed_modules import get_module

DMU_DIR = '/Users/rs548/GitHub/dmu_products/'

cosmo = FlatLambdaCDM(H0=100. , Om0 = (1-0.7))
#cosmo = Planck15

dV_z0  = cosmo.comoving_volume(0)
dV_z1  = cosmo.comoving_volume(1)
dV_z2  = cosmo.comoving_volume(2)


en1_moc = MOC(filename=DMU_DIR + 'dmu2/dmu2_field_coverages/'
                       +'ELAIS-N1_MOC.fits')

servs_moc = MOC(filename=DMU_DIR + 'dmu0/dmu0_DataFusion-Spitzer/data/'
                       +'DF-SERVS_ELAIS-N1_MOC.fits')
area = en1_moc.area
def volume(z1,z2,cosmo, moc =en1_moc):
    v = (cosmo.comoving_volume(z2) - cosmo.comoving_volume(z1)) * (moc.area/ (4* np.pi))
    return v

#print(volume(0.,1.,cosmo))

def bivariate(table,
              z1, z2,
              d1_min, d1_max, d1_bin_width, d1_name='cigale_dustlumin',
              d2_min, d2_max, d2_bin_width, d2_name='cigale_mstar', 
              cosmo=cosmo, 
              show_sample=False, 
              show_LF = False,
              vmax=False, 
              eff_area=False,
              moc = en1_moc):
    """Plot a general two dimansional function
    
    Take a catalogue as input with two columns and plot a 2d distribution with 
    volume weighting
    
    Inputs
    ------
    bin_wdith: float
      Width of bins in log10(L)
      
    Outputs
    ------
    """
    z = table['redshift']
    d1 = table[d1_name]
    d2 = table[d2_name]
    
    

    #Make redshift bin mask
    mask_z = (  (x > z1) 
                & (x < z2))


    #Apply redshift mask to redshifts and both columns
    z = z[mask_z]
    d1 = d1[mask_z]
    d2 = d2[mask_z]
    
    try:
        d1_unit = d1.unit
    except:
        d1_unit = 'Unknown unit'
        
    try:
        d2_unit = d2.unit
    except:
        d2_unit = 'Unknown unit'


    if show_sample:
        plt.scatter(z,np.log10(d1), s = 10)
        plt.xlabel('redshift z')
        plt.ylabel('$log_{10}$ Dimension 1 ($L/L_{\odot}$)')
        plt.show()

    nbins = 20 
    if bin_width is not None:
        nbins = int((np.log10(Lmax) - np.log10(Lmin) )/ bin_width)
        
    #L_min = 10**38
    #L_max = 10**39
    galaxy_sample = np.array(y)
    redshifts = np.array(x)
    has_L = ~np.isnan(galaxy_sample)
    galaxy_sample = galaxy_sample[has_L]
    redshifts = redshifts[has_L]
    #print(len(galaxy_sample), len(z_max))
    if vmax:
        z_max = table['z_max']
        z_max = z_max[mask_z01]
        z_max = z_max[has_L]
    if eff_area:
        areas = table['eff_area']
        areas = areas[mask_z01]
        areas = areas[has_L]

    galaxy_bins = Table()
    #galaxy_bins.add_column(Column(data=np.linspace(L_min, L_max, nbins), name='L_centre_values'))
    galaxy_bins.add_column(Column(data=np.logspace(np.log10(Lmin), np.log10(Lmax), num=nbins+1, base=10.0), 
                                  name='L_centre_values'))

    #dL = (L_max-L_min)/20

    galaxy_bins.add_column(Column(np.full(len(galaxy_bins), np.nan), name='dN_by_dL'))

    n=0
    if vmax:
        for gal_bin in np.arange(nbins):
            L=galaxy_bins['L_centre_values'][gal_bin]
            #print(L)
            #Get the array of zmaxes for this L bin
            mask = ((galaxy_sample > (L) ) 
                               & (galaxy_sample < galaxy_bins['L_centre_values'][gal_bin+1]))
            z_max_bin = z_max[mask]
            if len(z_max_bin) == 0:
                continue
            #then perform the 1/Vmax sum by taking the element wise minimum of zmax and z2
            dN_by_dL = np.sum( (( u.megaparsec)**3 ) / ( volume(z1,np.minimum(z_max_bin, z2),cosmo, moc) ) )
            
            #Test for max effect
            #dN_by_dL = np.sum( (( u.megaparsec)**3 ) / ( volume(z1,np.minimum(redshifts[mask], z2),cosmo, moc) ) )
            
            if( np.sum(volume(z1,np.minimum(z_max_bin, z2),cosmo, moc))/ 
                  np.sum(volume(z1,np.full(len(z_max_bin), z2),cosmo, moc))) < 0.5:
                continue
            #print(dN_by_dL)
            #print(np.sum(np.minimum(z_max_bin, z2) != z2)/len(z_max_bin))
        
            binwidth = galaxy_bins['L_centre_values'][gal_bin+1] - galaxy_bins['L_centre_values'][gal_bin]
            log_binwidth = (np.log10(galaxy_bins['L_centre_values'][gal_bin+1]/Lsun) 
                            - np.log10(galaxy_bins['L_centre_values'][gal_bin]/Lsun))
            dN_by_dL= dN_by_dL / (log_binwidth)
        
            galaxy_bins['dN_by_dL'][gal_bin] = dN_by_dL
            n +=1       
        
    elif eff_area:
        for gal_bin in np.arange(nbins):
            L=galaxy_bins['L_centre_values'][gal_bin]
            #print(L)
            #areas_bin = areas[((galaxy_sample > (L) ) 
            #                   & (galaxy_sample < galaxy_bins['L_centre_values'][gal_bin+1]))]
            area_correct = moc.area_sq_deg/areas
            if len(area_correct) == 0:
                continue
            
            #print(len(area_correct))
            #print(len(
            #    (
            #    (galaxy_sample > (L) ) 
            #    & (galaxy_sample < galaxy_bins['L_centre_values'][gal_bin+1])
            #    ) ))
            dN_by_dL = np.sum(
                (
                (galaxy_sample > (L) ) 
                & (galaxy_sample < galaxy_bins['L_centre_values'][gal_bin+1])
                ) * area_correct)
            #print(dN_by_dL)
            dN_by_dL = dN_by_dL /( volume(z1,z2,cosmo, moc) / (( u.megaparsec)**3 ))
            #print(dN_by_dL)
            binwidth = galaxy_bins['L_centre_values'][gal_bin+1] - galaxy_bins['L_centre_values'][gal_bin]
            log_binwidth = (np.log10(galaxy_bins['L_centre_values'][gal_bin+1]/Lsun) 
                            - np.log10(galaxy_bins['L_centre_values'][gal_bin]/Lsun))
            dN_by_dL= dN_by_dL / (log_binwidth)
        
            galaxy_bins['dN_by_dL'][gal_bin] = dN_by_dL
            n +=1
        
        
    else:
        for gal_bin in np.arange(nbins):
            L=galaxy_bins['L_centre_values'][gal_bin]
            #print(L)
            dN_by_dL = np.sum((galaxy_sample > (L) ) & (galaxy_sample < galaxy_bins['L_centre_values'][gal_bin+1]))
            #print(dN_by_dL)
            dN_by_dL = dN_by_dL /( volume(z1,z2,cosmo, moc) / (( u.megaparsec)**3 ))
            #print(dN_by_dL)
            binwidth = galaxy_bins['L_centre_values'][gal_bin+1] - galaxy_bins['L_centre_values'][gal_bin]
            log_binwidth = (np.log10(galaxy_bins['L_centre_values'][gal_bin+1]/Lsun) 
                            - np.log10(galaxy_bins['L_centre_values'][gal_bin]/Lsun))
            dN_by_dL= dN_by_dL / (log_binwidth)
        
        
            galaxy_bins['dN_by_dL'][gal_bin] = dN_by_dL
            n +=1
    
    if show_LF:
        plt.scatter( np.log10(np.array(galaxy_bins['L_centre_values'])/Lsun), 
                    np.log10(np.array(galaxy_bins['dN_by_dL'])))
        #plt.xscale('log')
        plt.title('Luminosity function {} < z < {}'.format(z1, z2))
        plt.xlabel('$Log_{10}$ Luminosity ($L_{\odot}$)')
        plt.ylabel('Log Ï†($Mpc^{-3}$ $dex^{-1}$)')
        plt.ylim([-8.,0.])
        plt.xlim([8.,14.])
        #plt.plot(np.array([1,2,3,4]), np.array([5,6,5,6]))
    
        #plt.savefig('Luminosity Functions')
    return galaxy_bins
    
    
#plot_LF(0.8,1.,10**8.75 * Lsun, 10**14.25 * Lsun,catalogue, bin_width=0.5, 
#        show_sample=True, show_LF=True, vmax=True)
#plot_LF(0.8,1.,10**8.75 * Lsun, 10**14.25 * Lsun,catalogue, bin_width=0.5, 
#        show_sample=True, show_LF=True, vmax=False)
#plt.show()


#test = plot_LF(0.8,1.,10**8.75 * Lsun, 10**14.25 * Lsun,
#               grup_cat, bin_width=0.5, show_sample=True, show_LF=True, eff_area=True,
#              l_col='Lir')    
